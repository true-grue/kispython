# Практическое занятие №1

П.Н. Советов, РТУ МИРЭА

Конвентировал в `.md` Загороднев Дмитрий, ИВБО-03-20

**Задача 1**

Запустите IDLE. Проверьте работу интерпретатора на простых
арифметических примерах. Научитесь создавать новые программы в редакторе
IDLE, сохранять их с расширением `.py`, запускать программы.

Сравните интерактивный режим IDLE с IDE для Java или C++. Насколько вам
понадобится отладчик? Обсудите с преподавателем.

**Задача 2**

Выясните, есть ли ограничения в Питоне для вычислений с целыми числами.
Придумайте арифметическое выражение, на котором интерпретатор Питона
\"зависнет\".

А что насчет ограничений чисел с плавающих запятой? Какое максимальное
значение вы сумели получить до переполнения?

Научитесь работать с документацией по Питону. Найдите в документации
встроенную (builtin) арифметическую функцию, которые возвращают не одно,
а два значения разом.

Запишите число 42 с помощью 10 различных способов, чем разнообразнее,
тем лучше. Без арифметики и функций. В любом варианте должно соблюдаться
`== 42`.

**Задача 3**

В реализации Питона спрятано несколько \"пасхальных яиц\". С одним из
них мы уже сталкивались, это `import this`. Есть как-то связанное с
гравитацией. И еще одно, для тех, кто ленится написать даже самую первую
программу. И еще одно \-- для любителей языков программирования с
непохожим на Питон синтаксисом.

Удастся ли вам их обнаружить? Можете гуглить.

**Задача 4**

Представим, что в Питоне отсутствует операция умножения. Ее можно
заменить сложением. Если мы хотим умножить какое-то число x на 12, то
нам понадобится 11 сложений, правильно? Но можно обойтись меньшим числом
сложений.

Попробуйте составить программы для решения нижеследующих задач.

1.  Умножение на 12. 4 сложения.
2.  Умножение на 16. 4 сложения.
3.  Умножение на 15. 3 сложения и 2 вычитания.
4.  Умножение на 29. 6 сложений и одно вычитание.

Из арифметических операций можно использовать только явно указанные и в
указанном количестве. Входным аргументом является переменная x. Унарный
минус использовать нельзя.

Тело программы должно состоять из линейной последовательности
присваиваний. Оформите линейный код решения в виде функции.

Приведенные задачи имеют практическое применение в области
низкоуровневой оптимизации кода. Даже сегодня существуют процессоры без
встроенного блока аппаратного умножения. Кстати, эталонные результаты
для всех этих задач были получены автоматически с помощью так
называемого синтезатора программ.

**Задача 5**

Рассмотрим следующий код:

``` {.python}
(True * 2 + False) * -True
```

    -2


Что за странное выражение и странный результат?

**Задача 6**

К сообщениям об ошибках Питона нужно привыкать, в них нет ничего
страшного. Давайте специально напишем некорректный код для того, чтобы
получить каждое из указанных ниже сообщений об ошибках.

1.  SyntaxError: cannot assign to literal
2.  SyntaxError: invalid syntax
3.  NameError: name \... is not defined
4.  TypeError: unsupported operand type(s) for \...
5.  IndentationError: expected an indented block
6.  ZeroDivisionError: division by zero
7.  ValueError: math domain error
8.  OverflowError: math range error

**Задача 7**

Рассмотрим следующий код:

``` {.python}
0.6 + 0.3 == 0.9
```
    False


Что здесь произошло? Интерпретатор Питона сломался? Что на самом деле
представляют собой 0.6 и 0.3 внутри интерпретатора? Можно ли увидеть их
настоящие значения? Обсудите с преподавателем и
[поэкспериментируйте](https://float.exposed/0x44bf9400).

**Задача 8**

В Питоне можно использовать цепочки операций сравнения. Рассмотрите
следующие примеры и попробуйте объяснить код:


``` {.python}
x = 5
1 < x < 10
```
    True



``` {.python}
x = 5
1 < (x < 10)
```

 
    False



``` {.python}
1 < True
```

    False



 
``` {.python}
1 <  42 == 42
```
    True


**Задача 9**

Некто попытался реализовать \"наивную\" функцию умножения с помощью
сложений. К сожалению, в коде много ошибок. Сможете ли вы их исправить?

``` {.python}
def naive_mul(x, y):
   r = 1;
    for i in range(0, y - 1)
    x = x + r;
    end

naive_mul(10, 15)
```
```
 (<ipython-input-6-0e60a6c4c0d1>, line 3)"}
      File "<ipython-input-6-0e60a6c4c0d1>", line 3
        for i in range(0, y - 1)
        ^
    IndentationError: unexpected 
```

Добавьте к `naive_mul` автоматическое тестирование для проверки обоих
аргументов в диапазоне от 0 до 100. Сравнивайте с встроенным умножением,
используя конструкцию `assert`.

**Задача 10**

Существует старинный метод умножения по методу русского крестьянина.
Разобрать его проще на примере.

Предположим, мы хотим перемножить 10 и 15:
```
  10      15
  ------- -----
  5       30
  2       60
  1       120
  ```

В первом столбце последовательно записывают результаты деления на 2 с
отбрасыванием остатка. Во втором столбце находятся результаты умножения
на 2. Отмечаем нечетные числа в первом столбце. Складываем те числа в
правом столбце, которые стоят напротив отмеченных ранее чисел. То есть
30 + 120 = 150. В нашем случае мы не учитывали исходные числа при
сложении, но учитывать их, вообще говоря, может быть нужно.

В этом алгоритме используются лишь простейшие операции: умножение на 2,
целочисленное деление на 2, проверка на нечетность и сложение. Эти
операции соответствуют тем элементарным операциям, которые эффективно
выполняет любой процессор. Сам же алгоритм, несмотря на кажущуюся
необычность, является вариантом умножения в столбик при использовании
двоичного представления чисел:

       1111 
       1010 *
       ----
       0000
      1111
     0000
    1111

Задачи:

1.  Реализуйте функцию `fast_mul` в соответствии с алгоритмом двоичного
    умножения в столбик (без рекурсии). Добавьте автоматическое
    тестирование, как в случае с `naive_mul`.
2.  Реализуйте аналогичную функцию `fast_pow` для возведения в степень.
    Решение необходимо с помощью небольших модификаций предыдущего
    решения.

**Задача 11**

Реализуйте синтезатор программ `fast_mul_gen(y)` для примеров из задачи
4. Воспользуйтесь ранее полученным кодом `fast_mul`. Ваша функция должна
выдать текст функции `f(x)` (умножение на ранее заданный `y`), тело
которой состоит из некоторого числа присваиваний. Для вывода функции
используйте `print`. Добавьте автоматическое тестирование. Объясните,
почему в общем случае у вас получается большее количество сложений, чем
в примерах из задачи 4.

**Задача 12**

Скачайте игру [DandyBot](https://github.com/true-grue/DandyBot). Код для
своего игрока записывается в файле user_bot.py. Игра запускается с
помощью main.py.

Вот простой пример содержимого user_bot.py:

``` {.python}
def script(check, x, y):
    return 'right'
```

Игровая логика записывается исключительно в теле функции `script`. В
нашем случае игрок будет постоянно двигаться вправо.

Полный список действий, которые можно возвращать из функции `script`,
задающей \"интеллект\" игрока:

-   `'up'`. Двигаться вверх на клетку.
-   `'down'`. Двигаться вниз на клетку.
-   `'left'`. Двигаться влево на клетку.
-   `'right'`. Двигаться вправо на клетку.
-   `'pass'`. Ничего не делать.
-   `'take'`. Взять золото.

Для изучения среды есть функция `check`:

-   `check('player', x, y)`. `True`, если какой-то игрок в позиции (x,
    y).
-   `check('gold', x , y)`. Если золото в позиции (x, y), то вернуть его
    количество, иначе вернуть 0.
-   `check('wall', x, y)`. `True`, если стена в позиции (x, y).
-   `check('empty', x, y)`. `True`, если пусто в позиции (x, y).
-   `check('level')`. Вернуть номер текущего уровня.

Ваша задача --- пройти 4 уровня. Дополнительно устанавливаемыми
библиотеками и глобальными данными пользоваться нельзя.

Если игра Вам показалась слишком простой, то попробуйте ее улучшить:
упростите код, добавьте новые функции, уровни.

